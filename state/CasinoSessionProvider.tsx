import { useState, useEffect, useCallback } from "react";
import AsyncStorage from "@react-native-async-storage/async-storage";
import createContextHook from "@nkzw/create-context-hook";
import { generateSessionsFromCruise } from '@/lib/historicalSessionCalculator';
import type { BookedCruise } from '@/types/models';
import { safeDispatchEvent } from '@/lib/safeEventDispatch';

export type MachineType = 
  | 'penny-slots'
  | 'nickel-slots'
  | 'quarter-slots'
  | 'dollar-slots'
  | 'high-limit-slots'
  | 'video-poker'
  | 'blackjack'
  | 'roulette'
  | 'craps'
  | 'baccarat'
  | 'poker'
  | 'other';

export type Denomination = 0.01 | 0.05 | 0.25 | 1 | 5 | 10 | 25 | 100;

export interface CasinoSession {
  id: string;
  date: string;
  cruiseId?: string;
  machineId?: string;
  machineName?: string;
  startTime: string;
  endTime: string;
  durationMinutes: number;
  notes?: string;
  createdAt: string;
  buyIn?: number;
  cashOut?: number;
  winLoss?: number;
  machineType?: MachineType;
  denomination?: Denomination;
  pointsEarned?: number;
  jackpotHit?: boolean;
  jackpotAmount?: number;
  freePlayUsed?: number;
  compsReceived?: number;
}

export interface DailySessionSummary {
  date: string;
  totalGoldenMinutes: number;
  totalPlayedMinutes: number;
  sessions: CasinoSession[];
  percentageComplete: number;
  totalBuyIn: number;
  totalCashOut: number;
  netWinLoss: number;
  totalPointsEarned: number;
}

export interface MachineSessionAnalytics {
  machineId: string;
  machineName: string;
  totalSessions: number;
  totalPlayTimeMinutes: number;
  totalBuyIn: number;
  totalCashOut: number;
  netWinLoss: number;
  totalPointsEarned: number;
  avgSessionLength: number;
  avgBuyIn: number;
  avgWinLoss: number;
  winRate: number;
  lossRate: number;
  breakEvenRate: number;
  bestSession: CasinoSession | null;
  worstSession: CasinoSession | null;
  pointsPerHour: number;
  roi: number;
  performanceRating: 'excellent' | 'good' | 'average' | 'poor';
}

export interface SessionAnalytics {
  totalSessions: number;
  totalPlayTimeMinutes: number;
  totalBuyIn: number;
  totalCashOut: number;
  netWinLoss: number;
  totalPointsEarned: number;
  avgSessionLength: number;
  avgBuyIn: number;
  avgWinLoss: number;
  winRate: number;
  lossRate: number;
  breakEvenRate: number;
  bestSession: CasinoSession | null;
  worstSession: CasinoSession | null;
  pointsPerHour: number;
  machineTypeBreakdown: Record<MachineType, {
    sessions: number;
    totalWinLoss: number;
    avgWinLoss: number;
    winRate: number;
  }>;
  denominationBreakdown: Record<number, {
    sessions: number;
    totalWinLoss: number;
    avgWinLoss: number;
  }>;
  varianceStats: {
    standardDeviation: number;
    variance: number;
    maxWin: number;
    maxLoss: number;
    medianWinLoss: number;
  };
  machinePerformance: Record<string, {
    machineId: string;
    machineName: string;
    sessions: number;
    totalWinLoss: number;
    avgWinLoss: number;
    totalTimeMinutes: number;
    avgSessionLength: number;
    winRate: number;
    bestSession: number;
    worstSession: number;
  }>;
  streakData: {
    currentStreak: number;
    currentStreakType: 'win' | 'loss' | 'none';
    longestWinStreak: number;
    longestLossStreak: number;
  };
  theoreticalVsActual: {
    theoreticalLoss: number;
    actualLoss: number;
    variance: number;
    variancePercent: number;
    isRunningHot: boolean;
    isRunningCold: boolean;
  };
}

interface CasinoSessionState {
  sessions: CasinoSession[];
  isLoading: boolean;
  addSession: (session: Omit<CasinoSession, 'id' | 'createdAt'>) => Promise<CasinoSession>;
  removeSession: (sessionId: string) => Promise<void>;
  updateSession: (sessionId: string, updates: Partial<CasinoSession>) => Promise<void>;
  getSessionsForDate: (date: string) => CasinoSession[];
  getDailySummary: (date: string, goldenMinutes: number) => DailySessionSummary;
  getTotalPlayedForDate: (date: string) => number;
  clearSessionsForDate: (date: string) => Promise<void>;
  getSessionAnalytics: () => SessionAnalytics;
  getSessionsByMachineType: (machineType: MachineType) => CasinoSession[];
  getSessionsByDenomination: (denomination: Denomination) => CasinoSession[];
  getSessionsByMachine: (machineId: string) => CasinoSession[];
  getMachineAnalytics: (machineId: string) => MachineSessionAnalytics | null;
  generateHistoricalSessions: (cruises: BookedCruise[], avgPPH?: number, forceRegenerate?: boolean) => Promise<number>;
  hasSessionsForCruise: (cruiseId: string) => boolean;
  getTotalPointsForCruise: (cruiseId: string) => number;
  clearAllAutoGeneratedSessions: () => Promise<void>;
  addQuickMachineWin: (data: {
    machineId: string;
    machineName: string;
    denomination: Denomination;
    winAmount: number;
    sessionDuration: number;
    isJackpot?: boolean;
    jackpotAmount?: number;
    pointsEarned?: number;
    notes?: string;
  }) => Promise<CasinoSession>;
  reload: () => Promise<void>;
}

const STORAGE_KEY = 'easyseas_casino_sessions';

export const [CasinoSessionProvider, useCasinoSessions] = createContextHook((): CasinoSessionState => {
  const [sessions, setSessions] = useState<CasinoSession[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  const persistSessions = useCallback(async (newSessions: CasinoSession[]) => {
    try {
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(newSessions));
      console.log('[CasinoSessionProvider] Persisted sessions:', newSessions.length);
    } catch (error) {
      console.error('[CasinoSessionProvider] Failed to persist sessions:', error);
    }
  }, []);

  const loadSessions = useCallback(async () => {
    try {
      setIsLoading(true);
      const stored = await AsyncStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored) as CasinoSession[];
        setSessions(parsed);
        console.log('[CasinoSessionProvider] Loaded sessions:', parsed.length);
      }
    } catch (error) {
      console.error('[CasinoSessionProvider] Failed to load sessions:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    loadSessions();
  }, [loadSessions]);

  const addSession = useCallback(async (sessionData: Omit<CasinoSession, 'id' | 'createdAt'>): Promise<CasinoSession> => {
    const newSession: CasinoSession = {
      ...sessionData,
      id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString(),
    };

    const newSessions = [...sessions, newSession];
    setSessions(newSessions);
    await persistSessions(newSessions);
    
    console.log('[CasinoSessionProvider] Added session:', newSession.id, 'points:', newSession.pointsEarned);
    
    if (newSession.cruiseId && newSession.pointsEarned) {
      console.log('[CasinoSessionProvider] Dispatching points update event for cruise:', newSession.cruiseId, 'points:', newSession.pointsEarned);
      safeDispatchEvent('casinoSessionPointsUpdated', { cruiseId: newSession.cruiseId, points: newSession.pointsEarned });
    }
    
    return newSession;
  }, [sessions, persistSessions]);

  const removeSession = useCallback(async (sessionId: string) => {
    const newSessions = sessions.filter(s => s.id !== sessionId);
    setSessions(newSessions);
    await persistSessions(newSessions);
    console.log('[CasinoSessionProvider] Removed session:', sessionId);
  }, [sessions, persistSessions]);

  const updateSession = useCallback(async (sessionId: string, updates: Partial<CasinoSession>) => {
    const oldSession = sessions.find(s => s.id === sessionId);
    const newSessions = sessions.map(s =>
      s.id === sessionId ? { ...s, ...updates } : s
    );
    setSessions(newSessions);
    await persistSessions(newSessions);
    console.log('[CasinoSessionProvider] Updated session:', sessionId);
    
    const updatedSession = newSessions.find(s => s.id === sessionId);
    if (updatedSession?.cruiseId && oldSession?.pointsEarned !== updatedSession.pointsEarned) {
      const pointsDelta = (updatedSession.pointsEarned || 0) - (oldSession?.pointsEarned || 0);
      if (pointsDelta !== 0) {
        console.log('[CasinoSessionProvider] Dispatching points delta event for cruise:', updatedSession.cruiseId, 'delta:', pointsDelta);
        safeDispatchEvent('casinoSessionPointsUpdated', { cruiseId: updatedSession.cruiseId, points: pointsDelta });
      }
    }
  }, [sessions, persistSessions]);

  const getSessionsForDate = useCallback((date: string): CasinoSession[] => {
    return sessions.filter(s => s.date === date);
  }, [sessions]);

  const getTotalPlayedForDate = useCallback((date: string): number => {
    const dateSessions = sessions.filter(s => s.date === date);
    return dateSessions.reduce((total, s) => total + s.durationMinutes, 0);
  }, [sessions]);

  const getDailySummary = useCallback((date: string, goldenMinutes: number): DailySessionSummary => {
    const dateSessions = sessions.filter(s => s.date === date);
    const totalPlayedMinutes = dateSessions.reduce((total, s) => total + s.durationMinutes, 0);
    const percentageComplete = goldenMinutes > 0 
      ? Math.min(100, Math.round((totalPlayedMinutes / goldenMinutes) * 100))
      : 0;

    const totalBuyIn = dateSessions.reduce((total, s) => total + (s.buyIn || 0), 0);
    const totalCashOut = dateSessions.reduce((total, s) => total + (s.cashOut || 0), 0);
    const netWinLoss = dateSessions.reduce((total, s) => total + (s.winLoss || 0), 0);
    const totalPointsEarned = dateSessions.reduce((total, s) => total + (s.pointsEarned || 0), 0);

    return {
      date,
      totalGoldenMinutes: goldenMinutes,
      totalPlayedMinutes,
      sessions: dateSessions,
      percentageComplete,
      totalBuyIn,
      totalCashOut,
      netWinLoss,
      totalPointsEarned,
    };
  }, [sessions]);

  const clearSessionsForDate = useCallback(async (date: string) => {
    const newSessions = sessions.filter(s => s.date !== date);
    setSessions(newSessions);
    await persistSessions(newSessions);
    console.log('[CasinoSessionProvider] Cleared sessions for date:', date);
  }, [sessions, persistSessions]);

  const getSessionsByMachineType = useCallback((machineType: MachineType): CasinoSession[] => {
    return sessions.filter(s => s.machineType === machineType);
  }, [sessions]);

  const getSessionsByDenomination = useCallback((denomination: Denomination): CasinoSession[] => {
    return sessions.filter(s => s.denomination === denomination);
  }, [sessions]);

  const getSessionsByMachine = useCallback((machineId: string): CasinoSession[] => {
    return sessions.filter(s => s.machineId === machineId);
  }, [sessions]);

  const getMachineAnalytics = useCallback((machineId: string): MachineSessionAnalytics | null => {
    const machineSessions = sessions.filter(s => s.machineId === machineId);
    
    if (machineSessions.length === 0) {
      return null;
    }

    const machineName = machineSessions[0].machineName || 'Unknown Machine';
    const totalPlayTimeMinutes = machineSessions.reduce((sum, s) => sum + s.durationMinutes, 0);
    const totalBuyIn = machineSessions.reduce((sum, s) => sum + (s.buyIn || 0), 0);
    const totalCashOut = machineSessions.reduce((sum, s) => sum + (s.cashOut || 0), 0);
    const netWinLoss = machineSessions.reduce((sum, s) => sum + (s.winLoss || 0), 0);
    const totalPointsEarned = machineSessions.reduce((sum, s) => sum + (s.pointsEarned || 0), 0);

    const avgSessionLength = totalPlayTimeMinutes / machineSessions.length;
    const avgBuyIn = totalBuyIn / machineSessions.length;
    const avgWinLoss = netWinLoss / machineSessions.length;

    const sessionsWithResults = machineSessions.filter(s => s.winLoss !== undefined);
    const winningSessions = sessionsWithResults.filter(s => (s.winLoss || 0) > 0).length;
    const losingSessions = sessionsWithResults.filter(s => (s.winLoss || 0) < 0).length;
    const breakEvenSessions = sessionsWithResults.filter(s => (s.winLoss || 0) === 0).length;

    const winRate = sessionsWithResults.length > 0 ? (winningSessions / sessionsWithResults.length) * 100 : 0;
    const lossRate = sessionsWithResults.length > 0 ? (losingSessions / sessionsWithResults.length) * 100 : 0;
    const breakEvenRate = sessionsWithResults.length > 0 ? (breakEvenSessions / sessionsWithResults.length) * 100 : 0;

    const sortedByWinLoss = [...sessionsWithResults].sort((a, b) => (b.winLoss || 0) - (a.winLoss || 0));
    const bestSession = sortedByWinLoss.length > 0 ? sortedByWinLoss[0] : null;
    const worstSession = sortedByWinLoss.length > 0 ? sortedByWinLoss[sortedByWinLoss.length - 1] : null;

    const totalHours = totalPlayTimeMinutes / 60;
    const pointsPerHour = totalHours > 0 ? totalPointsEarned / totalHours : 0;

    const roi = totalBuyIn > 0 ? (netWinLoss / totalBuyIn) * 100 : 0;

    let performanceRating: 'excellent' | 'good' | 'average' | 'poor' = 'average';
    if (roi > 20 && winRate > 60) performanceRating = 'excellent';
    else if (roi > 0 && winRate > 45) performanceRating = 'good';
    else if (roi < -30 || winRate < 30) performanceRating = 'poor';

    return {
      machineId,
      machineName,
      totalSessions: machineSessions.length,
      totalPlayTimeMinutes,
      totalBuyIn,
      totalCashOut,
      netWinLoss,
      totalPointsEarned,
      avgSessionLength,
      avgBuyIn,
      avgWinLoss,
      winRate,
      lossRate,
      breakEvenRate,
      bestSession,
      worstSession,
      pointsPerHour,
      roi,
      performanceRating,
    };
  }, [sessions]);

  const hasSessionsForCruise = useCallback((cruiseId: string): boolean => {
    return sessions.some(s => s.cruiseId === cruiseId);
  }, [sessions]);

  const getTotalPointsForCruise = useCallback((cruiseId: string): number => {
    const cruiseSessions = sessions.filter(s => s.cruiseId === cruiseId);
    const totalPoints = cruiseSessions.reduce((sum, s) => sum + (s.pointsEarned || 0), 0);
    console.log('[CasinoSessionProvider] Total points for cruise:', cruiseId, 'points:', totalPoints, 'from', cruiseSessions.length, 'sessions');
    return totalPoints;
  }, [sessions]);

  const clearAllAutoGeneratedSessions = useCallback(async () => {
    const manualSessions = sessions.filter(s => !s.notes?.includes('Auto-calculated'));
    setSessions(manualSessions);
    await persistSessions(manualSessions);
    console.log('[CasinoSessionProvider] Cleared', sessions.length - manualSessions.length, 'auto-generated sessions');
  }, [sessions, persistSessions]);

  const generateHistoricalSessions = useCallback(async (
    cruises: BookedCruise[],
    avgPPH: number = 400,
    forceRegenerate: boolean = false
  ): Promise<number> => {
    console.log('[CasinoSessionProvider] Generating historical sessions for', cruises.length, 'cruises', forceRegenerate ? '(FORCE REGENERATE)' : '');
    
    if (forceRegenerate) {
      await clearAllAutoGeneratedSessions();
    }
    
    let generatedCount = 0;
    const newSessions: CasinoSession[] = [];
    const currentSessions = forceRegenerate 
      ? sessions.filter(s => !s.notes?.includes('Auto-calculated'))
      : sessions;

    for (const cruise of cruises) {
      const existingSessions = currentSessions.filter(s => s.cruiseId === cruise.id);
      const expectedSessionsData = generateSessionsFromCruise(cruise, avgPPH);
      const expectedSessionCount = expectedSessionsData.length;
      
      if (!forceRegenerate && existingSessions.length >= expectedSessionCount) {
        console.log('[CasinoSessionProvider] Cruise already has sufficient sessions:', {
          cruiseId: cruise.id,
          shipName: cruise.shipName,
          existing: existingSessions.length,
          expected: expectedSessionCount,
        });
        continue;
      }

      const sessionsToGenerate = expectedSessionCount - existingSessions.length;
      console.log('[CasinoSessionProvider] Generating sessions for cruise:', {
        cruiseId: cruise.id,
        shipName: cruise.shipName,
        sailDate: cruise.sailDate,
        existing: existingSessions.length,
        expected: expectedSessionCount,
        toGenerate: sessionsToGenerate,
        nights: cruise.nights,
        earnedPoints: cruise.earnedPoints || cruise.casinoPoints,
      });
      
      if (expectedSessionsData.length === 0) {
        console.log('[CasinoSessionProvider] No sessions could be generated for cruise:', cruise.id);
        continue;
      }

      const sessionsToAdd = forceRegenerate 
        ? expectedSessionsData
        : expectedSessionsData.slice(existingSessions.length);

      for (const sessionData of sessionsToAdd) {
        const newSession: CasinoSession = {
          ...sessionData,
          id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          createdAt: new Date().toISOString(),
        };
        newSessions.push(newSession);
        generatedCount++;
      }
    }

    if (newSessions.length > 0) {
      const updatedSessions = forceRegenerate 
        ? [...currentSessions, ...newSessions]
        : [...sessions, ...newSessions];
      setSessions(updatedSessions);
      await persistSessions(updatedSessions);
      console.log('[CasinoSessionProvider] Generated and saved', generatedCount, 'historical sessions');
    } else {
      console.log('[CasinoSessionProvider] No new sessions to generate');
    }

    return generatedCount;
  }, [sessions, persistSessions, clearAllAutoGeneratedSessions]);

  const getSessionAnalytics = useCallback((): SessionAnalytics => {
    const totalSessions = sessions.length;
    const totalPlayTimeMinutes = sessions.reduce((sum, s) => sum + s.durationMinutes, 0);
    const totalBuyIn = sessions.reduce((sum, s) => sum + (s.buyIn || 0), 0);
    const totalCashOut = sessions.reduce((sum, s) => sum + (s.cashOut || 0), 0);
    const netWinLoss = sessions.reduce((sum, s) => sum + (s.winLoss || 0), 0);
    const totalPointsEarned = sessions.reduce((sum, s) => sum + (s.pointsEarned || 0), 0);

    const avgSessionLength = totalSessions > 0 ? totalPlayTimeMinutes / totalSessions : 0;
    const avgBuyIn = totalSessions > 0 ? totalBuyIn / totalSessions : 0;
    const avgWinLoss = totalSessions > 0 ? netWinLoss / totalSessions : 0;

    const sessionsWithResults = sessions.filter(s => s.winLoss !== undefined);
    const winningSessions = sessionsWithResults.filter(s => (s.winLoss || 0) > 0).length;
    const losingSessions = sessionsWithResults.filter(s => (s.winLoss || 0) < 0).length;
    const breakEvenSessions = sessionsWithResults.filter(s => (s.winLoss || 0) === 0).length;

    const winRate = sessionsWithResults.length > 0 ? (winningSessions / sessionsWithResults.length) * 100 : 0;
    const lossRate = sessionsWithResults.length > 0 ? (losingSessions / sessionsWithResults.length) * 100 : 0;
    const breakEvenRate = sessionsWithResults.length > 0 ? (breakEvenSessions / sessionsWithResults.length) * 100 : 0;

    const sortedByWinLoss = [...sessionsWithResults].sort((a, b) => (b.winLoss || 0) - (a.winLoss || 0));
    const bestSession = sortedByWinLoss.length > 0 ? sortedByWinLoss[0] : null;
    const worstSession = sortedByWinLoss.length > 0 ? sortedByWinLoss[sortedByWinLoss.length - 1] : null;

    const totalHours = totalPlayTimeMinutes / 60;
    const pointsPerHour = totalHours > 0 ? totalPointsEarned / totalHours : 0;

    const machineTypeBreakdown = {} as SessionAnalytics['machineTypeBreakdown'];
    const machineTypes: MachineType[] = ['penny-slots', 'nickel-slots', 'quarter-slots', 'dollar-slots', 'high-limit-slots', 'video-poker', 'blackjack', 'roulette', 'craps', 'baccarat', 'poker', 'other'];
    
    machineTypes.forEach(mt => {
      const mtSessions = sessions.filter(s => s.machineType === mt);
      const mtWinLoss = mtSessions.reduce((sum, s) => sum + (s.winLoss || 0), 0);
      const mtWins = mtSessions.filter(s => (s.winLoss || 0) > 0).length;
      machineTypeBreakdown[mt] = {
        sessions: mtSessions.length,
        totalWinLoss: mtWinLoss,
        avgWinLoss: mtSessions.length > 0 ? mtWinLoss / mtSessions.length : 0,
        winRate: mtSessions.length > 0 ? (mtWins / mtSessions.length) * 100 : 0,
      };
    });

    const denominationBreakdown = {} as SessionAnalytics['denominationBreakdown'];
    const denoms: Denomination[] = [0.01, 0.05, 0.25, 1, 5, 10, 25, 100];
    
    denoms.forEach(d => {
      const dSessions = sessions.filter(s => s.denomination === d);
      const dWinLoss = dSessions.reduce((sum, s) => sum + (s.winLoss || 0), 0);
      denominationBreakdown[d] = {
        sessions: dSessions.length,
        totalWinLoss: dWinLoss,
        avgWinLoss: dSessions.length > 0 ? dWinLoss / dSessions.length : 0,
      };
    });

    const winLossValues = sessionsWithResults.map(s => s.winLoss || 0);
    const meanWinLoss = winLossValues.length > 0 ? winLossValues.reduce((a, b) => a + b, 0) / winLossValues.length : 0;
    const squaredDiffs = winLossValues.map(v => Math.pow(v - meanWinLoss, 2));
    const variance = squaredDiffs.length > 0 ? squaredDiffs.reduce((a, b) => a + b, 0) / squaredDiffs.length : 0;
    const standardDeviation = Math.sqrt(variance);
    const maxWin = winLossValues.length > 0 ? Math.max(...winLossValues) : 0;
    const maxLoss = winLossValues.length > 0 ? Math.min(...winLossValues) : 0;
    const sortedWinLoss = [...winLossValues].sort((a, b) => a - b);
    const medianWinLoss = sortedWinLoss.length > 0 
      ? sortedWinLoss.length % 2 === 0
        ? (sortedWinLoss[sortedWinLoss.length / 2 - 1] + sortedWinLoss[sortedWinLoss.length / 2]) / 2
        : sortedWinLoss[Math.floor(sortedWinLoss.length / 2)]
      : 0;

    let currentStreak = 0;
    let currentStreakType: 'win' | 'loss' | 'none' = 'none';
    let longestWinStreak = 0;
    let longestLossStreak = 0;
    let tempWinStreak = 0;
    let tempLossStreak = 0;

    const sortedByDate = [...sessionsWithResults].sort((a, b) => 
      new Date(a.date).getTime() - new Date(b.date).getTime()
    );

    sortedByDate.forEach((s, i) => {
      const wl = s.winLoss || 0;
      if (wl > 0) {
        tempWinStreak++;
        tempLossStreak = 0;
        if (tempWinStreak > longestWinStreak) longestWinStreak = tempWinStreak;
        if (i === sortedByDate.length - 1) {
          currentStreak = tempWinStreak;
          currentStreakType = 'win';
        }
      } else if (wl < 0) {
        tempLossStreak++;
        tempWinStreak = 0;
        if (tempLossStreak > longestLossStreak) longestLossStreak = tempLossStreak;
        if (i === sortedByDate.length - 1) {
          currentStreak = tempLossStreak;
          currentStreakType = 'loss';
        }
      } else {
        tempWinStreak = 0;
        tempLossStreak = 0;
        if (i === sortedByDate.length - 1) {
          currentStreak = 0;
          currentStreakType = 'none';
        }
      }
    });

    const avgHouseEdge = 0.08;
    const theoreticalLoss = totalBuyIn * avgHouseEdge;
    const actualLoss = netWinLoss < 0 ? Math.abs(netWinLoss) : -netWinLoss;
    const theoVariance = actualLoss - theoreticalLoss;
    const theoVariancePercent = theoreticalLoss > 0 ? (theoVariance / theoreticalLoss) * 100 : 0;

    const machinePerformance: SessionAnalytics['machinePerformance'] = {};
    const machineIds = new Set(sessions.filter(s => s.machineId).map(s => s.machineId!));
    
    machineIds.forEach(machineId => {
      const machineSessions = sessions.filter(s => s.machineId === machineId);
      if (machineSessions.length === 0) return;

      const machineName = machineSessions[0].machineName || 'Unknown';
      const machineWinLoss = machineSessions.reduce((sum, s) => sum + (s.winLoss || 0), 0);
      const machineTimeMinutes = machineSessions.reduce((sum, s) => sum + s.durationMinutes, 0);
      const machineWins = machineSessions.filter(s => (s.winLoss || 0) > 0).length;
      const sortedSessions = [...machineSessions].sort((a, b) => (b.winLoss || 0) - (a.winLoss || 0));

      machinePerformance[machineId] = {
        machineId,
        machineName,
        sessions: machineSessions.length,
        totalWinLoss: machineWinLoss,
        avgWinLoss: machineWinLoss / machineSessions.length,
        totalTimeMinutes: machineTimeMinutes,
        avgSessionLength: machineTimeMinutes / machineSessions.length,
        winRate: (machineWins / machineSessions.length) * 100,
        bestSession: sortedSessions.length > 0 ? (sortedSessions[0].winLoss || 0) : 0,
        worstSession: sortedSessions.length > 0 ? (sortedSessions[sortedSessions.length - 1].winLoss || 0) : 0,
      };
    });

    console.log('[CasinoSessionProvider] Session analytics calculated:', {
      totalSessions,
      netWinLoss,
      winRate,
      pointsPerHour,
      machinesTracked: machineIds.size,
    });

    return {
      totalSessions,
      totalPlayTimeMinutes,
      totalBuyIn,
      totalCashOut,
      netWinLoss,
      totalPointsEarned,
      avgSessionLength,
      avgBuyIn,
      avgWinLoss,
      winRate,
      lossRate,
      breakEvenRate,
      bestSession,
      worstSession,
      pointsPerHour,
      machineTypeBreakdown,
      denominationBreakdown,
      varianceStats: {
        standardDeviation,
        variance,
        maxWin,
        maxLoss,
        medianWinLoss,
      },
      streakData: {
        currentStreak,
        currentStreakType,
        longestWinStreak,
        longestLossStreak,
      },
      theoreticalVsActual: {
        theoreticalLoss,
        actualLoss,
        variance: theoVariance,
        variancePercent: theoVariancePercent,
        isRunningHot: theoVariance < -theoreticalLoss * 0.2,
        isRunningCold: theoVariance > theoreticalLoss * 0.2,
      },
      machinePerformance,
    };
  }, [sessions]);

  const addQuickMachineWin = useCallback(async (data: {
    machineId: string;
    machineName: string;
    denomination: Denomination;
    winAmount: number;
    sessionDuration: number;
    isJackpot?: boolean;
    jackpotAmount?: number;
    pointsEarned?: number;
    notes?: string;
  }): Promise<CasinoSession> => {
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const startTime = now.toISOString();
    const endTime = new Date(now.getTime() + data.sessionDuration * 60000).toISOString();

    const existingTodaySessions = sessions.filter(s => 
      s.date === dateStr && 
      s.machineId === data.machineId
    );

    if (existingTodaySessions.length > 0) {
      const lastSession = existingTodaySessions[existingTodaySessions.length - 1];
      
      const updatedWinLoss = (lastSession.winLoss || 0) + data.winAmount;
      const updatedDuration = lastSession.durationMinutes + data.sessionDuration;
      const updatedPoints = (lastSession.pointsEarned || 0) + (data.pointsEarned || 0);
      const updatedNotes = data.notes 
        ? `${lastSession.notes || ''}\n${data.notes}`.trim()
        : lastSession.notes;

      const updates = {
        endTime,
        durationMinutes: updatedDuration,
        winLoss: updatedWinLoss,
        pointsEarned: updatedPoints,
        jackpotHit: data.isJackpot || lastSession.jackpotHit,
        jackpotAmount: data.isJackpot 
          ? (data.jackpotAmount || data.winAmount) + (lastSession.jackpotAmount || 0)
          : lastSession.jackpotAmount,
        notes: updatedNotes,
      };

      await updateSession(lastSession.id, updates);

      console.log('[CasinoSessionProvider] Updated existing session with win:', {
        sessionId: lastSession.id,
        winAmount: data.winAmount,
        newTotal: updatedWinLoss,
      });

      const updatedSession = { ...lastSession, ...updates };
      return updatedSession;
    }

    const newSession = await addSession({
      date: dateStr,
      machineId: data.machineId,
      machineName: data.machineName,
      startTime,
      endTime,
      durationMinutes: data.sessionDuration,
      denomination: data.denomination,
      winLoss: data.winAmount,
      pointsEarned: data.pointsEarned,
      jackpotHit: data.isJackpot,
      jackpotAmount: data.isJackpot ? (data.jackpotAmount || data.winAmount) : undefined,
      machineType: 'penny-slots',
      notes: data.notes,
    });

    console.log('[CasinoSessionProvider] Created new machine win session:', {
      sessionId: newSession.id,
      machine: data.machineName,
      winAmount: data.winAmount,
    });

    return newSession;
  }, [sessions, addSession, updateSession]);

  const reload = useCallback(async () => {
    console.log('[CasinoSessionProvider] Reloading sessions from storage...');
    await loadSessions();
  }, [loadSessions]);

  return {
    sessions,
    isLoading,
    addSession,
    removeSession,
    updateSession,
    getSessionsForDate,
    getDailySummary,
    getTotalPlayedForDate,
    clearSessionsForDate,
    getSessionAnalytics,
    getSessionsByMachineType,
    getSessionsByDenomination,
    getSessionsByMachine,
    getMachineAnalytics,
    generateHistoricalSessions,
    hasSessionsForCruise,
    getTotalPointsForCruise,
    clearAllAutoGeneratedSessions,
    addQuickMachineWin,
    reload,
  };
});
